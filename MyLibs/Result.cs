using System;

namespace MyLibs
{
    /// <summary>
    /// A struct that represents a result of an operation.
    /// </summary>
    public struct Result
    {
        /// <summary>
        /// True if the operation was successful.
        /// </summary>
        public bool Success { get; set; }

        /// <summary>
        /// Initializes a new <see cref="Result"/>.
        /// </summary>
        /// <param name="success">If the operation was successful or not.</param>
        public Result(bool success)
        {
            Success = success;
        }

        /// <summary>
        /// Get the result of a function. Catches any exceptions thrown by the function.
        /// </summary>
        /// <typeparam name="T">The type that the function returns.</typeparam>
        /// <param name="func">The function to execute.</param>
        /// <returns>A <see cref="Result{T, TError}"/> where TError is an <see cref="Exception"/>.</returns>
        public static Result<T, Exception> GetResult<T>(Func<T> func)
        {
            try
            {
                var value = func();

                return new Result<T, Exception>(true, null, value);
            }
            #pragma warning disable CA1031 // Do not catch general exception types
            catch (Exception ex)
            {
                return new Result<T, Exception>(false, ex);
            }
            #pragma warning restore CA1031 // Do not catch general exception types
        }

        #region Overrides
        public override string ToString()
        {
            return Success.ToString();
        }

        public override int GetHashCode()
        {
            return Success.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            return obj != null && obj is Result result && result.Success == Success;
        }

        public static bool operator ==(Result left, Result right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(Result left, Result right)
        {
            return !(left == right);
        }
        #endregion
    }

    /// <summary>
    /// A struct that represents the result of an operation with a return value.
    /// </summary>
    /// <typeparam name="T">The type that the operation should return.</typeparam>
    public struct Result<T>
    {
        /// <summary>
        /// True if the operation was successful.
        /// </summary>
        public bool Success { get; set; }

        /// <summary>
        /// If the operation was successful, the result of the operation.
        /// </summary>
        public T Value { get; set; }

        /// <summary>
        /// Initializes a new <see cref="Result{T}"/>.
        /// </summary>
        /// <param name="success">If the operation was successful or not.</param>
        /// <param name="value">The result of the operation.</param>
        public Result(bool success, T value = default)
        {
            Success = success;
            Value = value;
        }

        #region Overrides
        public override string ToString()
        {
            return $"{Success}|{Value}";
        }

        public override int GetHashCode()
        {
            return ToString().GetHashCode();
        }

        public override bool Equals(object obj)
        {
            return obj != null && obj is Result<T> result && result.Success == Success && result.Value.Equals(Value);
        }

        public static bool operator ==(Result<T> left, Result<T> right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(Result<T> left, Result<T> right)
        {
            return !(left == right);
        }
        #endregion
    }

    /// <summary>
    /// A struct that represents the result of an operation with a return value an error type.
    /// </summary>
    /// <typeparam name="T">The type that the operation should return.</typeparam>
    /// <typeparam name="TError">The type of error the operation could return.</typeparam>
    public struct Result<T, TError>
    {
        /// <summary>
        /// True if the operation was successful.
        /// </summary>
        public bool Success { get; set; }

        /// <summary>
        /// If the operation was unsuccessful, the error that occurred.
        /// </summary>
        public TError Error { get; set; }

        /// <summary>
        /// If the operation was successful, the result of the operation.
        /// </summary>
        public T Value { get; set; }

        /// <summary>
        /// Initializes a new <see cref="Result{T, TError}"/>.
        /// </summary>
        /// <param name="success">If the operation was successful or not.</param>
        /// <param name="error">The error generated by the operation.</param>
        /// <param name="value">The result of the operation.</param>
        public Result(bool success, TError error = default, T value = default)
        {
            Success = success;
            Error = error;
            Value = value;
        }

        #region Overrides
        public override string ToString()
        {
            return $"{Success}|{Error}|{Value}";
        }

        public override int GetHashCode()
        {
            return ToString().GetHashCode();
        }

        public override bool Equals(object obj)
        {
            return obj != null && obj is Result<T, TError> result && result.Success == Success && result.Error.Equals(Error) && result.Value.Equals(Value);
        }

        public static bool operator ==(Result<T, TError> left, Result<T, TError> right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(Result<T, TError> left, Result<T, TError> right)
        {
            return !(left == right);
        }
        #endregion
    }
}
